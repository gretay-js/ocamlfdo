(**************************************************************************)
(*                                                                        *)
(*                                 OCamlFDO                               *)
(*                                                                        *)
(*                     Greta Yorsh, Jane Street Europe                    *)
(*                                                                        *)
(*   Copyright 2019 Jane Street Group LLC                                 *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)
open Core

let verbose = ref false
let strict = ref false

module Perf_profile = struct
  (* Perf profile format as output of perf script -F pid,ip,brstack*)

  type mispredict_flag = M | P | NOT_SUPPORTED
  [@@deriving compare, sexp]

  type br = {
    from_addr : int64;
    to_addr : int64;
    mispredict : mispredict_flag;
    (* cycles : int; *)
  } [@@deriving compare, sexp]

  type sample = {
    ip: int64;
    brstack: br list;
  } [@@deriving compare, sexp]

  type t = sample list
  [@@deriving compare, sexp]

  let parse_br s =
    match String.split s ~on:'/' with
    | [from_addr;to_addr;m;t;a;c] ->
      let mispredict = match m with
        | "M" -> M
        | "P" -> P
        | "-" -> NOT_SUPPORTED
        | _ -> failwithf "Cannot parse mispredict flag %s in %s" m s ()
      in
      (* Parse and ignore t and a flags. *)
      begin match t with
      | "X" | "-" -> ()
      | _ -> failwithf "Cannot parse mispredict flag %s in %s" m s ()
      end;
      begin match a with
      | "A" | "-" -> ()
      | _ -> failwithf "Cannot parse mispredict flag %s in %s" a s ()
      end;
      (* Parse and ignore cycles. CR gyorsh: use for optimizations. *)
      let _cycles = Int.of_string c in
      {
        from_addr = Int64.of_string from_addr;
        to_addr = Int64.of_string to_addr;
        mispredict;
      }
    | _ -> failwithf "Cannot parse %s\n" s ()

  let print t =
    Printf.printf !"%{sexp:t}\n" t

  let rec parse brstack row =
    match row with
    | [] -> brstack
    | hd::tl ->
      let brstack = (parse_br hd)::brstack in parse brstack tl

  let split_on_whitespace row =
    let r = String.split ~on:' ' row in
    List.filter r ~f:String.is_empty

  let row_to_sample ~keep_pid t row =
    match split_on_whitespace row with
    | pid::ip::rest ->
      let pid = Int.of_string pid in
      if keep_pid pid then
        let sample =  {
          ip = Int64.of_string ip;
          brstack = parse [] rest;
        } in
        sample::t
      else
        t
      | _ -> failwithf "Cannot parse %s\n" row ()

  let pids = ref Int.Set.empty

  let check_keep_pid ?expected_pid p =
    if !verbose then begin
      if not (Int.Set.mem !pids p) then begin
        printf "Found new pid: %d" p;
        pids := Int.Set.add !pids p;
      end
    end;
    match expected_pid with
    | None -> true
    | Some expected_pid ->
      if expected_pid = p then true
      else begin
        if !verbose then
          printf "Mismatch pid: expected %L found %L\n" expected_pid p;
        false
      end

  let read filename ?expected_pid =
    if !verbose then
      printf "Reading perf profile generated by \
              \"perf script -F pid,ip,brstack\" from %s\n" filename;
    let chan = In_channel.create filename in
    let keep_pid = check_keep_pid ?expected_pid in
    In_channel.fold_lines chan [] (row_to_sample ~keep_pid)
    In_channel.close chan;
    if !verbose then begin
      print t;
      Printf.printf !"Found pids: %{sexp:int list}\n" !pids;
    end
    t
end

module Raw_layout : sig
  (* CR gyorsh: it has to be named t for csv  fields ppx to work. move to separate
     module. *)
  type t = {
    address : int64; (* start of function *)
    offset : int; (* offset from address *)
    index : int; (* index in the original layout *)
    position : int; (* new position in the permutation *)
  } [@@deriving fields, csv, compare, sexp]

  (* We don't need all the fields, but redundancy is used for validating
     the input. *)
  type p = t list [@@deriving sexp]

  val read : string -> p
  val print : p -> unit
  val print_t : t -> unit

end = struct
  type t = {
    address : int64; (* start of function *)
    offset : int; (* offset from address *)
    index : int; (* index in the original layout *)
    position : int; (* new position in the permutation *)
  } [@@deriving fields, csv, compare, sexp]

  type p = t list [@@deriving sexp]

  let print_t i =
    Printf.printf "0x%Lx:0x%x:%d:%d\n" i.address i.offset i.position i.position

  let print l =
    (* List.iter l ~f:print_t; *)
    Printf.printf !"%{sexp:p}\n" l

  let read filename =
    if !verbose then
      printf "Reading raw layout from %s\n" filename;
    let p = csv_load ~separator:':' filename in
    if !verbose then print p;
    p

end

module Rel_layout : sig
  type t = {
    func : string;
    labels : int list;
  } [@@deriving sexp]

  type p = t list [@@deriving sexp]

  val read : string -> p

  val writer : string option -> string -> int list -> unit

end = struct

  type t = {
    func : string;
    labels : int list;
  } [@@deriving sexp]

  type p = t list [@@deriving sexp]

  let print_t ~t outc =
    fprintf outc !"%{sexp:t}\n" t

  let print_p p outc =
    List.iter p ~f:(fun t -> print_t ~t outc)

  let read filename =
    if !verbose then
      printf "Reading layout from %s\n" filename;

    let p =
      match Parsexp_io.load (module Parsexp.Many) ~filename with
      | Ok p_sexp_list -> List.map p_sexp_list ~f:t_of_sexp
      | Error error ->
        Parsexp.Parse_error.report Caml.Format.std_formatter error ~filename;
        failwith "Cannot parse relative layout file"
    in
    (* let p = csv_load ~separator:':' filename in *)
    if !verbose then begin
      print_p p Out_channel.stdout;
      if p = [] then Printf.printf "Empty layout!\n"
    end;
    p

  let writer filename =
    match filename with
      | None -> (fun _ _ -> ())
      | Some filename ->
        (* CR gyorsh: fix this ugly hack to create an empty file
           and then append to it, if the file exists. *)
        Out_channel.close_no_err (Out_channel.create filename);
        (fun func labels ->
           let t = {func;labels;} in
           Out_channel.with_file filename ~f:(print_t ~t)
             ~binary:false
             ~append:true)

end

let time f x =
  let open Time in
  let start = now () in
  let fx = f x in
  let stop = now () in
  Printf.printf "Execution time: %s\n" (Span.to_string (abs_diff stop start));
  fx

let load_locations binary_filename =
  let elf_locations = Elf_locations.create ~elf_executable:binary_filename in
  if !verbose then Elf_locations.print_dwarf elf_locations;
  elf_locations

let decode_perf_data _locations filename writer =
  if !verbose then
    printf "Reading perf profile from %s\n" filename;
  failwith "Not implemented: read_perf_data"

let print_fun_layout_item (key, data) =
  Printf.printf "position=%d linear_id=%d\n" key data

let print_fun_layout ~key:name ~data:(fun_layout : (int,int) Hashtbl.t) =
  Printf.printf "%s (%d)\n" name (Hashtbl.length fun_layout);
  let sorted_fun_layout =
    List.sort (Hashtbl.to_alist fun_layout)
      ~compare:(fun (k1, _) (k2,_) -> Int.compare k1 k2)
  in
  List.iter sorted_fun_layout ~f:print_fun_layout_item

let print_layout layout =
  Hashtbl.iteri layout ~f:print_fun_layout

let _to_func file =
  match String.chop_suffix file ~suffix:".linear" with
  | None -> None
  | Some name ->
    let symbol_prefix =
      if X86_proc.system = X86_proc.S_macosx then "_" else ""
    in
    Some (X86_proc.string_of_symbol symbol_prefix name)

(* Use addresses from permutation locations to find linear id layout. *)
let decode_item ~func ~locations fun_layout (l:Raw_layout.t) =
  let program_counter = Int64.(l.address + (Int64.of_int l.offset)) in
  match Elf_locations.resolve_from_cache locations ~program_counter with
  | None ->
    if !verbose then
      Printf.printf "Elf location NOT FOUND at 0x%Lx\n" program_counter;
    fun_layout
  | Some (file,line) ->
    if !verbose then
      Printf.printf "%s:%d\n" file line;
    (* Check that the func symbol name from the binary where
       permutation comes from matches the function name encoded
       as filename into our special dwarf info. *)
    match String.chop_suffix file ~suffix:".linear" with
    | None ->
      Report.log (sprintf "Ignoring %s in %s\n" func file);
      fun_layout
    | Some func_name_dwarf ->
      begin
        if func_name_dwarf = func then begin
          match Map.add fun_layout ~key:l.position ~data:line with
          | `Duplicate ->
            failwithf
              "Cannot add linear_id %d at position %d in function %s"
              line l.position func ()
          | `Ok fun_layout ->
            if !verbose then
              Printf.printf "Adding %s %d %d\n" func l.position line;
            fun_layout
        end else
          failwithf "func_name_dwarf = %s func = %s\n"
            func_name_dwarf func ()
      end

(* Split raw layout into functions and decode each one in turn. *)
let decode_layout_all locations permutation writer  =
  let open Raw_layout in
  (* Resolve all addresses that need decoding *)
  let addresses = List.map permutation
                    ~f:(fun r -> Int64.(r.address + (of_int r.offset)))
  in
  Elf_locations.resolve_all locations addresses ~reset:true;
  (* Decode each function and record its layout. *)
  let rec decode_func_layout permutation layout =
    match permutation with
    | [] -> layout
    | hd::tl ->
      let func_start = hd.address in
      let func = Elf_locations.resolve_function_starting_at
                   ~program_counter:func_start ~reset:true
                   locations in
      match func with
      | None ->
        Report.log (sprintf "Not found function at 0x%Lx\n" func_start);
        decode_func_layout tl layout
      | Some func -> begin
          if !verbose then Printf.printf "Function %s\n" func;
          let (l, rest) = List.split_while permutation
                            ~f:(fun r -> r.address = func_start) in
          let fun_layout = List.fold l
                             ~init:Int.Map.empty
                             ~f:(decode_item ~func ~locations) in
          let labels = Int.Map.data fun_layout in
          let layout =
            if List.is_empty labels then begin
              Report.log (sprintf "Cannot decode layout of function %s at 0x%Lx\n"
                            func func_start);
              layout
            end
            else begin
              (* Save decoded layout *)
              writer func labels;
              String.Map.add_exn layout ~key:func ~data:labels
            end in
          decode_func_layout rest layout
        end
  in
  decode_func_layout permutation (String.Map.empty)

let convert_layout (l:Rel_layout.p) =
  List.fold l ~init:String.Map.empty
    ~f:(fun layout p ->
      String.Map.add_exn layout ~key:p.func ~data:p.labels)

let setup_reorder ~binary_filename
      ~perf_profile_filename
      ~raw_layout_filename
      ~rel_layout_filename
      ~linearid_layout_filename
      ~random_order
      ~gen_linearid_layout =
  if random_order then begin
    (* let random_state = Random.State.make [ deterministic seed ]; *)
    Reorder.Random Random.State.default
  end else begin
    match binary_filename with
    | None -> begin
        match rel_layout_filename with
        | Some rel_layout_filename ->
          let layout =
            convert_layout (Rel_layout.read rel_layout_filename) in
          Reorder.Cfg_label layout
        | None ->
          match linearid_layout_filename with
          | Some linearid_layout_filename ->
            let layout =
              convert_layout (Rel_layout.read linearid_layout_filename) in
            Reorder.Linear_id layout
          | None -> Reorder.Identity
      end
    | Some binary_filename -> begin
        let locations = load_locations binary_filename in
        match raw_layout_filename with
        | Some raw_layout_filename ->
          let raw_layout = Raw_layout.read raw_layout_filename in
          let writer = Rel_layout.writer gen_linearid_layout in
          let layout = decode_layout_all locations raw_layout writer in
          Reorder.Linear_id layout
        | None -> begin
            match perf_profile_filename with
            | None -> Reorder.Identity
            | Some perf_profile_filename -> begin
                (* CR gyorsh: decoding raw perf data should be separate from
                   reordering algorithm setup. *)
                (* CR gyorsh: check buildid of the samples. Use owee? *)
                (* CR gyorsh: Check pid of the samples. Use owee? *)
                let perf_profile = Perf_profile.read perf_profile_filename in
                let linearid_profile = decode_perf_data locations perf_profile  in
                let gen_linearid_profile =
                  match gen_linearid_profile with
                  | None -> perf_profile_filename ^ ".linearid"
                  | Some f -> f
                in
                Linearid_profile.write linearid_profile gen_linearid_profile;
                Reorder.CachePlus linearid_profile
              end
          end
      end
  end


let call_ocamlopt args =
  (* Set debug "-g" to emit dwarf locations. *)
  Clflags.debug := true;
  Clflags.extended_debug := true;
  (* set command line to args to call ocamlopt *)
  begin match args with
  | None | Some [] ->
    if !verbose then
      printf "Missing compilation command\n"
  | Some args ->
    if !verbose then begin
      printf "ocamlopt ";
      List.iter ~f:(fun s -> printf " %s" s) args;
      printf "\n"
    end
  end;
  let args = (Array.of_list (Option.value args ~default:[])) in
  let len = Array.length args in
  let argc = Array.length Sys.argv in
  assert (len < argc);
  Array.blit ~src:args ~src_pos:0 ~dst:Sys.argv ~dst_pos:1 ~len;
  (* CR gyorsh: Can't resize args array. Fake missing arguments. Better way? *)
  Array.fill Sys.argv ~pos:(len+1) ~len:(argc-len-1) "-absname";  (* -inlining-report? *)
  Optmain.main ()


let check_equal f ~new_body =
  let open Linearize in
  let rec equal i1 i2 =
    (* Format.kasprintf prerr_endline "@;%a" Printlinear.instr i1;
     * Format.kasprintf prerr_endline "@;%a" Printlinear.instr i2; *)
    if i1.desc = i2.desc &&
       i1.id = i2.id &&
       Reg.array_equal i1.arg i2.arg &&
       Reg.array_equal i1.res i2.res &&
       Reg.Set.equal i1.live i2.live &&
       (Debuginfo.compare i1.dbg i2.dbg) = 0
    then begin
      if i1.desc = Lend then true
      else equal i1.next i2.next
    end
    else begin
      Format.kasprintf prerr_endline "Equality failed in %s on:@;%a@;%a"
        f.fun_name
        Printlinear.instr i1
        Printlinear.instr i2;
      false
    end
  in
  if not (equal f.fun_body new_body) then begin
    let name = X86_proc.string_of_symbol "" f.fun_name in
    (* Separate files for before and after to make it easier to diff *)
    Report.linear ~name "Before" f;
    Report.linear ~name "After" {f with fun_body = new_body};
    if !strict then
      failwithf "Conversion from linear to cfg and back to linear \
                 is not an identity function %s.\n" name ()
  end

let print_linear msg f =
  if false then
  if !verbose then begin
    Printf.printf "%s processing %s\n" f.Linearize.fun_name msg;
    Format.kasprintf prerr_endline "@;%a" Printlinear.fundecl f
  end

let rec remove_discriminator = function
  | [] -> []
  | item::t ->
    if String.is_suffix item.Debuginfo.dinfo_file ~suffix:".linear" then t
    else item::(remove_discriminator t)

let rec remove_linear_discriminator i =
  let open Linearize in
  match i.desc with
  | Lend -> i
  | _ -> begin
      { i with dbg = remove_discriminator i.dbg;
               next = remove_linear_discriminator i.next;
      }
    end

let remove_linear_discriminators f =
  let open Linearize in
  { f with fun_dbg = remove_discriminator f.fun_dbg;
           fun_body = remove_linear_discriminator f.fun_body;
  }

(* CR gyorsh: this is intended as a report at source level and human readable form,
   like inlining report. Currently, just prints the IRs.
   Could share infrastructure with inlining report to map back to source when
   reordering involves inlined functions.
   CR gyorsh: add separate "dump" flags for all passes in ocamlfdo, printing
   to stdout similarly to -dcmm -dlinear in the compiler, etc. *)
let write_reorder_report f cfg newf newcfg =
  if not (phys_equal cfg newcfg) then begin
    (* Separate files for before and after make it easier to diff *)
    let name = X86_proc.string_of_symbol "" f.Linearize.fun_name in
    Report.linear ~name "Before-Reorder" f;
    Report.linear ~name "After-Reorder" newf;
    Report.cfg ~name "Before-Reorder" cfg;
    Report.cfg ~name "After-Reorder" newcfg;
  end

let main ~binary_filename
      ~perf_profile_filename
      ~raw_layout_filename
      ~rel_layout_filename
      ~linearid_layout_filename
      ~gen_rel_layout
      ~gen_linearid_layout
      ~random_order
      ~eliminate_dead_blocks
      ~eliminate_fallthrough_blocks
      ~remove_linear_ids
      ~reorder_report
      ~preserve_orig_labels
      args =

  let algo = setup_reorder ~binary_filename
               ~perf_profile_filename
               ~raw_layout_filename
               ~rel_layout_filename
               ~linearid_layout_filename
               ~random_order
               ~gen_linearid_layout
  in
  let reorder = Reorder.reorder ~algo in
  let w_rel = Rel_layout.writer gen_rel_layout in
  let write_rel_layout new_cfg =
    let new_layout = Cfg_builder.get_layout new_cfg in
    let fun_name = Cfg_builder.get_name new_cfg in
    w_rel fun_name new_layout
  in
  let validate f ~new_body =
    match algo with
    | Reorder.Identity ->
      if eliminate_fallthrough_blocks ||
         eliminate_dead_blocks ||
         not preserve_orig_labels
      then ()
      else
        check_equal f ~new_body
    | _ -> ()
  in
  let transform f =
    print_linear "Before" f;
    let cfg = Cfg_builder.from_linear f ~preserve_orig_labels in
    let new_cfg = reorder cfg in
    write_rel_layout new_cfg;
    (* If we eliminate dead blocks before a transformation
       then some algorithms might not apply because they rely
       on perf data based on original instructions. *)
    if eliminate_fallthrough_blocks then (* implies dead block elimination *)
      Cfg_builder.eliminate_fallthrough_blocks new_cfg
    else if eliminate_dead_blocks then
      Cfg_builder.eliminate_dead_blocks new_cfg;
    let new_body = Cfg_builder.to_linear new_cfg in
    validate f ~new_body;
    let fnew = {f with fun_body = new_body} in
    if reorder_report then write_reorder_report f cfg fnew new_cfg;
    let fnew =
      if remove_linear_ids then
        remove_linear_discriminators fnew
      else fnew
    in
    print_linear "After" fnew;
    fnew
  in
  Reoptimize.setup ~f:transform;
  at_exit Report.finish;
  call_ocamlopt args;
  Report.finish ()

let command =
  Command.basic
    ~summary:"Feedback-directed optimizer for Ocaml"
    ~readme:(fun () ->
      "
Build your program with ocamlfdo to enable extra debug info
for low-level optimizations (currently, only linearize pass):
$ ocamlfdo -- <standard ocamlopt options including -o prog.exe>

Collect perf profile with LBR information:
$ perf record -e cycles:u -j any,u -o perf.data <prog.exe> <args..>

Run ocamlfdo with exactly the same version of the source code and
options as above:
$ ocamlfdo -perf-profile <perf.data> -binary <prog.exe> -- \\
           <standard ocamlopt options including -o prog.fdo.exe>

Important: ocamlfdo relies on compiler-libs and thus the build of ocamlfdo must
match the build of ocamlopt used above.
"
    )
    Command.Let_syntax.(
      let%map_open
        v = flag "-verbose" ~aliases:["-v"] no_arg ~doc:" verbose"
      and q = flag "-q" no_arg ~doc:" quiet"
      and remove_linear_ids = flag "-remove-linear-ids" no_arg
                                ~doc:" remove extra dwarf info with linear ids"
      and eliminate_dead_blocks =
        flag "-edb" no_arg ~doc:" eliminate dead blocks"
      and eliminate_fallthrough_blocks =
        flag "-efb" no_arg ~doc:" eliminate fallthrough blocks, implies -edb"
      and preserve_orig_labels =
        flag "-preserve-orig-labels" no_arg
          ~doc:" do not eliminate labels (for validation)"
      and gen_rel_layout =
        flag "-gen-layout" (optional Filename.arg_type)
          ~doc:"filename generate relative layout and write to <filename>"
      and gen_linearid_layout =
        flag "-gen-linearid-layout" (optional Filename.arg_type)
          ~doc:"filename generate relative layout and write to <filename>"
      and random_order =
        flag "-random-order" no_arg ~doc:" reorder blocks at random"
      and binary_filename =
        flag "-binary" (optional Filename.arg_type)
          ~doc:"filename elf binary to optimize"
      and perf_profile_filename =
        flag "-perf-profile" (optional Filename.arg_type)
          ~doc:"perf.data output of perf record"
      and gen_linearid_profile =
        flag "-gen-linearid-profile" (optional Filename.arg_type)
          ~doc:"filename output decoded perf profile"
      and linearid_profile_filename =
        flag "-linearid-profile" (optional Filename.arg_type)
          ~doc:"filename use decoded perf profile"
      and raw_layout_filename =
        flag "-raw-layout" (optional Filename.arg_type)
          ~doc:"filename block layout for reordering: raw binary addresses"
      and rel_layout_filename =
        flag "-rel-layout" (optional Filename.arg_type)
          ~doc:"filename block layout for reordering relative to function start,\
                does not require -binary"
      and linearid_layout_filename =
        flag "-linearid-layout" ~aliases:["-layout"] (optional Filename.arg_type)
          ~doc:"filename same as -rel-layout but uses linear id not cfg labels"
      and reorder_report =
        flag "-reorder-report" no_arg ~doc: " Emit files showing the decisions"
      and args = flag "--" (escape)
                   ~doc:"ocamlopt_args standard options passed to opcamlopt"
      in
      if v then verbose := true;
      if q then verbose := false;
      if !verbose then Report.verbose := true;
      (* CR gyorsh: use choose_one to reduce the mess below? *)
      if !verbose then begin
        if preserve_orig_labels &&
           (eliminate_dead_blocks || eliminate_fallthrough_blocks) then begin
          Printf.printf "Warning: Ignoring -preserve-orig-labels.\n";
          Printf.printf "Incompatible with -edb and -efb\n"
        end;
        if random_order then begin
          if not (perf_profile_filename = None) ||
             not (raw_layout_filename = None) ||
             not (rel_layout_filename = None) ||
             not (linearid_layout_filename = None) ||
             not (binary_filename = None)
          then begin
            Printf.printf
              "Warning: Ignoring -perf-profile -raw-layout -layout \
               -linearid-layout -binary. ";
            Printf.printf "Incompatible with -random\n";
          end
        end;
        if binary_filename = None then begin
          if not (perf_profile_filename = None) ||
             not (raw_layout_filename = None) then begin
            Printf.printf "Warning: ignoring -raw_layout and -perf-profile. ";
            Printf.printf "Cannot use without -binary.\n";
          end
        end else begin
          if (perf_profile_filename = None) &&
             (raw_layout_filename = None) then
            begin
              Printf.printf "Warning: Ignoring -binary. ";
              Printf.printf "Cannot use without -perf-profile or -raw-layout.\n";
            end
        end
      end;
      fun () -> main
                  ~binary_filename
                  ~perf_profile_filename
                  ~raw_layout_filename
                  ~rel_layout_filename
                  ~linearid_layout_filename
                  ~gen_rel_layout
                  ~gen_linearid_layout
                  ~random_order
                  ~eliminate_dead_blocks
                  ~eliminate_fallthrough_blocks
                  ~remove_linear_ids
                  ~reorder_report
                  ~preserve_orig_labels
                  ~gen_linearid_profile
                  ~linearid_profile_filename
                  args)

let () = Command.run command
